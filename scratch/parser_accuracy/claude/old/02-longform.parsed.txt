- Capture timing variations: Measure and log command injection-to-response
latency across different command types (simple vs. complex), system
loads, and cold vs. warm sessions to establish realistic timeout
thresholds
- Verify output buffer boundaries: Test with commands producing varying
output sizes (empty, single-line, multi-screen) to ensure your
capture-pane buffer size is adequate and you're not truncating responses
or capturing stale output
- Test session recovery and reattachment: Verify you can detach from a
session, reattach programmatically, and resume automation without losing
context or encountering synchronization issues
- Validate escape sequence handling: Confirm your output parser correctly
strips or interprets ANSI color codes, cursor movements, and control
characters that tmux captures, especially when the controlled application
uses rich terminal formatting
- Exercise failure modes systematically: Test behavior when tmux isn't
installed, sessions already exist with the same name, the controlled
application crashes mid-session, commands timeout, and rapid command
queuing occurs to ensure graceful degradation
