› Provide a detailed checklist (at least eight bullet points) of best practices for testing command-line automation
  harnesses that interact with tmux sessions.
• Best Practices
  - Exercise the harness under different tmux layouts (single pane, split panes, nested sessions) to ensure pane
    targeting logic never confuses coordinates or session names.
  - Script the creation and teardown of temporary tmux sessions so each test starts from a clean slate and leaves no
    orphaned panes that could influence later runs.
  - Capture full tmux server logs plus the harness’s own stdout/stderr for every test case; these paired artifacts make
    it much easier to diagnose pane focus or timing issues.
  - Introduce artificial latency between keystrokes and command responses to prove the harness copes with slow or bursty
    terminal output instead of assuming instant feedback.
  - Validate synchronization primitives by asserting that prompts appear before the harness sends the next command,
    preventing race conditions that only surface intermittently.
  - Run negative tests that deliberately trigger failures (bad commands, permissions errors, killed panes) and confirm
    the harness retries or reports errors clearly.
  - Use deterministic fixtures for environment variables and working directories so pane commands run in predictable
    contexts regardless of the developer’s local tmux settings.
  - Verify cleanup paths by interrupting the harness mid-run  and checking that it restores
    the user’s tmux environment without leaving stray windows or modified options.
  - Include compatibility checks across tmux versions on your support matrix, because subtle differences in formats
    (e.g., display-message tokens) can break parsing logic.
